{"version":3,"sources":["file:///Users/sunjia/project/cocos/NewProject_1/extensions/live2d_cubismsdk_cocoscreator/static/assets/Rendering/Masking/CubismMaskTransform.ts"],"names":["CubismMaskTransform","math","uniqueId","_uniqueId","toVec4","Vec4","offset","x","y","scale","constructor","args","Vec2","ZERO","clone","equals","other","strictEquals","copyWith","DEFAULT"],"mappings":";;;wEAWMA,mB;;;;;;;AAJGC,MAAAA,I,OAAAA,I;;;;AAPT;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACMD,MAAAA,mB,GAAN,MAAMA,mBAAN,CAAsE;AAMpE;AACA;;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B,mBAARE,QAAQ,GAAG;AAC5B;AACA,cAAI,KAAKC,SAAL,GAAiB,IAArB,EAA2B;AACzB,iBAAKA,SAAL,GAAiB,CAAjB;AACD;;AAED,iBAAO,KAAKA,SAAL,EAAP;AACD;AAED;AACF;AACA;AACA;AACE;;;AACOC,QAAAA,MAAM,GAAc;AACzB,iBAAO,IAAIH,IAAI,CAACI,IAAT,CAAc,KAAKC,MAAL,CAAYC,CAA1B,EAA6B,KAAKD,MAAL,CAAYE,CAAzC,EAA4C,KAAKC,KAAjD,EAAwDT,mBAAmB,CAACE,QAA5E,CAAP;AACD,SAjCmE,CAmCpE;;AAEA;;;AAMOQ,QAAAA,WAAW,CAACC,IAAD,EAA8D;AAAA;;AAAA,cAA7DA,IAA6D;AAA7DA,YAAAA,IAA6D,GAAJ,EAAI;AAAA;;AAAA,eALhEL,MAKgE;;AAHhF;AAGgF,eAFhEG,KAEgE;AAC9E,eAAKH,MAAL,mBAAcK,IAAI,CAACL,MAAnB,2BAA6BL,IAAI,CAACW,IAAL,CAAUC,IAAV,CAAeC,KAAf,EAA7B;AACA,eAAKL,KAAL,kBAAaE,IAAI,CAACF,KAAlB,0BAA2B,CAA3B;AACD;;AAEMM,QAAAA,MAAM,CAACC,KAAD,EAAsC;AACjD,iBAAO,SAASA,KAAT,GAAiB,IAAjB,GAAwB,KAAKV,MAAL,CAAYS,MAAZ,CAAmBC,KAAK,CAACV,MAAzB,KAAoC,KAAKG,KAAL,IAAcO,KAAK,CAACP,KAAvF;AACD;;AAEMQ,QAAAA,YAAY,CAACD,KAAD,EAAsC;AACvD,iBAAO,SAASA,KAAhB;AACD;;AAEME,QAAAA,QAAQ,CACbP,IADa,EAEQ;AAAA;;AAAA,cADrBA,IACqB;AADrBA,YAAAA,IACqB,GADoC,EACpC;AAAA;;AACrB,iBAAO,IAAIX,mBAAJ,CAAwB;AAC7BM,YAAAA,MAAM,mBAAEK,IAAI,CAACL,MAAP,4BAAiB,KAAKA,MADC;AAE7BG,YAAAA,KAAK,kBAAEE,IAAI,CAACF,KAAP,2BAAgB,KAAKA;AAFG,WAAxB,CAAP;AAID;;AA/DmE,O;AACpE;;AAEA;AAHIT,MAAAA,mB,CAIWG,S,GAAoB,C;;;AA+D5B,YAAMgB,OAAO,kCAAG,IAAInB,mBAAJ,EAAhB;SADCA,mB,KAAAA,mB;;yBAGKA,mB","sourcesContent":["/**\r\n * Copyright(c) Live2D Inc. All rights reserved.\r\n *\r\n * Use of this source code is governed by the Live2D Open Software license\r\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\r\n */\r\n\r\nimport { math } from 'cc';\r\nimport type IStructLike from '../../IStructLike';\r\n\r\n/** Holds info used for masking. (struct) */\r\nclass CubismMaskTransform implements IStructLike<CubismMaskTransform> {\r\n  // #region Conversion\r\n\r\n  /** UniqueId backing field. */\r\n  private static _uniqueId: number = 0;\r\n\r\n  // この内容だけ正しいか精査が必要。内容がUnityの仕様に基づく処理のため。\r\n  // CubismToMaskClipPosの計算に影響を与えている？ 要調査\r\n  /**\r\n   * HACK Prevents dynamic batching of <see cref=\"CubismRenderer\"/>s that are masked.\r\n   *\r\n   * As Unity transforms vertex positions into world space on dynamic batching,\r\n   * and masking relies on vertex positions to be in local space,\r\n   * masking isn't compatible with dynamic batching.\r\n   *\r\n   * Unity exposes a shader tag for disabling dynamic batching (\"DynamicBatching\"), but this would make it necessary for creating separate shaders...\r\n   */\r\n  private static get uniqueId() {\r\n    // We just have to make sure consecutive drawables with the same mask aren't batched; having more than 1024 cases in a row seems pretty rare, so...\r\n    if (this._uniqueId > 1024) {\r\n      this._uniqueId = 0;\r\n    }\r\n\r\n    return this._uniqueId++;\r\n  }\r\n\r\n  /**\r\n   * Converts a CubismMaskTransform to a Vector4.\r\n   * @returns Value to convert.\r\n   */\r\n  // public static implicit operator Vector4(CubismMaskTransform value)\r\n  public toVec4(): math.Vec4 {\r\n    return new math.Vec4(this.offset.x, this.offset.y, this.scale, CubismMaskTransform.uniqueId);\r\n  }\r\n\r\n  // #endregion\r\n\r\n  /** Offset in model space. */\r\n  public readonly offset: Readonly<math.Vec2>;\r\n\r\n  /** Scale in model space. */\r\n  public readonly scale: number;\r\n\r\n  public constructor(args: { offset?: Readonly<math.Vec2>; scale?: number } = {}) {\r\n    this.offset = args.offset ?? math.Vec2.ZERO.clone();\r\n    this.scale = args.scale ?? 0;\r\n  }\r\n\r\n  public equals(other: CubismMaskTransform): boolean {\r\n    return this === other ? true : this.offset.equals(other.offset) && this.scale == other.scale;\r\n  }\r\n\r\n  public strictEquals(other: CubismMaskTransform): boolean {\r\n    return this === other;\r\n  }\r\n\r\n  public copyWith(\r\n    args: { offset?: Readonly<math.Vec2>; scale?: number } = {}\r\n  ): CubismMaskTransform {\r\n    return new CubismMaskTransform({\r\n      offset: args.offset ?? this.offset,\r\n      scale: args.scale ?? this.scale,\r\n    });\r\n  }\r\n}\r\n\r\nnamespace CubismMaskTransform {\r\n  export const DEFAULT = new CubismMaskTransform();\r\n}\r\nexport default CubismMaskTransform;\r\n"]}