{"version":3,"sources":["file:///Users/sunjia/project/cocos/NewProject_1/extensions/live2d_cubismsdk_cocoscreator/static/assets/Framework/Physics/CubismPhysicsMath.ts"],"names":["CubismPhysicsMath","math","degreesToRadian","degrees","Math","PI","directionToRadian","from","to","q1","atan2","y","x","q2","getAngleDiff","ret","radianToDirection","totalAngle","Vec2","sin","cos","getRangeValue","min","max","maxValue","minValue","abs","getDefaultValue","normalize","parameter","parameterValue","normalizedMinimum","normalizedMaximum","normalizedDefault","isInverted","result","maximumValue","minimumValue","clamp","minNormValue","maxNormValue","middleNormValue","middleValue","paramValue","sign","nLength","pLength","normalized","clamped"],"mappings":"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","sourcesContent":["/**\r\n * Copyright(c) Live2D Inc. All rights reserved.\r\n *\r\n * Use of this source code is governed by the Live2D Open Software license\r\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\r\n */\r\n\r\nimport { math } from 'cc';\r\nimport type CubismParameter from '../../Core/CubismParameter';\r\n\r\n/** Math utilities for physics. */\r\nexport default class CubismPhysicsMath {\r\n  public static degreesToRadian(degrees: number): number {\r\n    return (degrees / 180.0) * Math.PI;\r\n  }\r\n\r\n  /**\r\n   * Gets angle from both vector direction.\r\n   * @param from From vector.\r\n   * @param to To vector.\r\n   * @returns Angle of radian.\r\n   */\r\n  public static directionToRadian(from: math.Vec2, to: math.Vec2): number {\r\n    const q1 = Math.atan2(to.y, to.x);\r\n    const q2 = Math.atan2(from.y, from.x);\r\n\r\n    return this.getAngleDiff(q1, q2);\r\n  }\r\n\r\n  public static getAngleDiff(q1: number, q2: number): number {\r\n    let ret = q1 - q2;\r\n\r\n    while (ret < -Math.PI) {\r\n      ret += Math.PI * 2.0;\r\n    }\r\n\r\n    while (ret > Math.PI) {\r\n      ret -= Math.PI * 2.0;\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  public static radianToDirection(totalAngle: number): math.Vec2 {\r\n    const ret = new math.Vec2(Math.sin(totalAngle), Math.cos(totalAngle));\r\n\r\n    return ret;\r\n  }\r\n\r\n  private static getRangeValue(min: number, max: number): number {\r\n    const maxValue = Math.max(min, max);\r\n    const minValue = Math.min(min, max);\r\n    return Math.abs(maxValue - minValue);\r\n  }\r\n\r\n  private static getDefaultValue(min: number, max: number): number {\r\n    const minValue = Math.min(min, max);\r\n    return minValue + CubismPhysicsMath.getRangeValue(min, max) / 2.0;\r\n  }\r\n\r\n  public static normalize(\r\n    parameter: CubismParameter,\r\n    parameterValue: number,\r\n    normalizedMinimum: number,\r\n    normalizedMaximum: number,\r\n    normalizedDefault: number,\r\n    isInverted: boolean = false\r\n  ): { normalized: number; clamped: number } {\r\n    let result = 0.0;\r\n\r\n    const maxValue = Math.max(parameter.maximumValue, parameter.minimumValue);\r\n    const minValue = Math.min(parameter.maximumValue, parameter.minimumValue);\r\n\r\n    parameterValue = math.clamp(parameterValue, minValue, maxValue);\r\n\r\n    const minNormValue = Math.min(normalizedMinimum, normalizedMaximum);\r\n    const maxNormValue = Math.max(normalizedMinimum, normalizedMaximum);\r\n    const middleNormValue = normalizedDefault;\r\n\r\n    const middleValue = CubismPhysicsMath.getDefaultValue(minValue, maxValue);\r\n    const paramValue = parameterValue - middleValue;\r\n    switch (Math.sign(paramValue)) {\r\n      case 1: {\r\n        const nLength = maxNormValue - middleNormValue;\r\n        const pLength = maxValue - middleValue;\r\n        if (pLength != 0.0) {\r\n          result = paramValue * (nLength / pLength);\r\n          result += middleNormValue;\r\n        }\r\n\r\n        break;\r\n      }\r\n      case -1: {\r\n        const nLength = minNormValue - middleNormValue;\r\n        const pLength = minValue - middleValue;\r\n        if (pLength != 0.0) {\r\n          result = paramValue * (nLength / pLength);\r\n          result += middleNormValue;\r\n        }\r\n        break;\r\n      }\r\n      case 0: {\r\n        result = middleNormValue;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return { normalized: isInverted ? result : result * -1.0, clamped: parameterValue };\r\n  }\r\n}\r\n"]}